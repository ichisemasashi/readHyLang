
## **PYTHON BASICS**


![Image](../images/000085.jpg)


プログラミング言語Pythonには、様々な構文、標準ライブラリ関数、対話型開発環境の機能などがあります。幸いなことに、それらのほとんどを無視することができます。あなたは、いくつかの便利な小さなプログラムを書くのに十分な量を学ぶ必要があるだけです。

しかし、何かをする前にプログラミングの基本的な概念を学ぶ必要があります。修行中の魔法使いのように、これらの概念は難解で退屈に思えるかもしれませんが、いくつかの知識と練習を積めば、魔法の杖のようにコンピュータを操り、信じられないような偉業を成し遂げることができるようになります。

この章では、*REPL* (Read-Evaluate-Print Loop) とも呼ばれる *インタラクティブシェル* に入力するよう促すいくつかの例があります。これは、Python の命令を一度に一つずつ実行 (*execute*) し、結果を即座に表示することができるものです。対話型シェルを使うことは、Pythonの基本的な命令が何をするものなのかを学ぶのに最適な方法です。読むだけよりも、実行した方がずっと記憶に残りますよ。

### **インタラクティブシェルに式を入力する** 

対話型シェルを実行するには、「はじめに」のセットアップ手順の際にダウンロードしたはずのMuエディタを起動します。Windowsでは、スタートメニューを開き、"Mu "と入力し、Muアプリケーションを開きます。macOSの場合は、アプリケーションフォルダを開き、**Mu**をダブルクリックします。 **新規作成**ボタンをクリックし、空のファイルを*blank.py*として保存します。この空ファイルを**Run**ボタンをクリックするか、`F5`を押して実行すると、インタラクティブシェルが開かれ、Muエディタのウィンドウの下部に開く新しいペインとして表示されます。インタラクティブシェルでは、`>>` プロンプトが表示されるはずです。

プロンプトで `2 + 2` と入力し、Pythonに簡単な計算をさせます。これで、Muのウィンドウは次のようになります。

```
>>> 2 + 2
4
>>>
```


Python では、`2 + 2` は *式* と呼ばれ、この言語で最も基本的なプログラミング命令の一種である。式は値(`2`など)と演算子(`+`など)から構成され、常に1つの値に*評価*(つまり、削減)することができます。つまり、Pythonのコードの中で、値を使うことができる場所ならどこでも式を使うことができるのです。

先ほどの例では、`2 + 2` は評価されて、`4`という1つの値になります。演算子を含まない単一の値も式とみなされますが、このように自分自身に対してのみ評価されます。

```
>>> 2
2
```

**ERRORS ARE OKAY!**

プログラムは、コンピュータが理解できないコードを含んでいるとクラッシュし、Pythonはエラーメッセージを表示するようになります。エラーメッセージはあなたのコンピュータを壊すことはありません。間違いを恐れないでください。*クラッシュ*は、プログラムの実行が予期せず停止したことを意味するだけです。

エラーについてもっと詳しく知りたい場合は、正確なエラーメッセージのテキストをオンラインで検索して、より詳しい情報を得ることができます。また、*[https://nostarch.com/automatestuff2/](https://nostarch.com/automatestuff2/)*にあるリソースで、よくあるPythonのエラーメッセージとその意味の一覧を確認することができます。


Pythonの式では、他の演算子もたくさん使うことができます。例えば、[Table 1-1](#calibre_link-1652) はPythonのすべての数学演算子をリストアップしています。

**Table 1-1:** 数学演算子の優先順位の高いものから低いものまで

  **演算子**       **オペレーション**                       **例**            **に評価される。**
  ------------------ ----------------------------------- ---------------------- ------------------------
  `**`   Exponent                            `2 ** 3`   `8`
  `%`      Modulus/remainder                   `22 % 8`     `6`
  `//`     Integer division/floored quotient   `22 // 8`    `2`
  `/`      Division                            `22 / 8`     `2.75`
  `*`     Multiplication                      `3 * 5`     `15`
  `-`      Subtraction                         `5 - 2`      `3`
  `+`      Addition                            `2 + 2`      `4`

Pythonの演算子の*操作順序*（*優先順位*とも呼ばれます）は、数学のそれと似ています。演算子 `**` が最初に評価され、 `*`, `/`, `//`, `%` が左から右に評価され、 `+` と `-` が最後に評価されます（これも左から右へ評価されます）。必要であれば、括弧を使用して通常の優先順位を上書きすることができます。演算子と値の間の空白は Python では重要ではありません(行頭のインデントを除く)が、空白を1つ入れることは慣習となっています。次の式を対話型シェルに入力します。

```
>>> 2 + 3 * 6
20
>>> (2 + 3) * 6
30
>>> 48565878 * 578453
28093077826734
>>> 2 ** 8
256
>>> 23 / 7
3.2857142857142856
>>> 23 // 7
3
>>> 23 % 7
2
>>> 2      +           2
4
>>> (5 - 1) * ((7 + 1) / (3 - 1))
16.0
```

いずれの場合も、プログラマであるあなたは式を入力しなければなりませんが、Pythonはそれを1つの値に評価するという大変な作業を行います。Pythonはここに示すように、1つの値になるまで式の一部を評価しつづけます。


![image](../images/000066.jpg)


演算子や値を組み合わせて式を作るこれらのルールは、コミュニケーションを助ける文法ルールと同じように、プログラミング言語としてのPythonの基本的な部分なのです。以下はその例です。

**これは文法的に正しい英文です。**

**これは文法的に正しい英語ではない文です。**

2行目は英語のルールに従っていないため、解析が困難です。同様に、不正なPython命令を入力すると、Pythonはそれを理解できず、ここに示すように `SyntaxError` エラーメッセージが表示されます。

```
>>> 5 +
  File "<stdin>", line 1
    5 +
      ^
SyntaxError: invalid syntax
>>> 42 + 5 + * 2
  File "<stdin>", line 1
    42 + 5 + * 2
             ^
SyntaxError: invalid syntax
```

命令が動作するかどうかは、いつでも対話型シェルに入力することでテストすることができます。コンピュータが壊れる心配はありません。起こりうる最悪の事態は、Pythonがエラーメッセージで応答することです。 プロのソフトウェア開発者は、コードを書いているときに常にエラーメッセージを受け取ります。

### **整数型、浮動小数点型、文字列型** 

式は単に値と演算子を組み合わせたものであり、常に1つの値として評価されることを覚えておいてください。*データ型*は値のカテゴリであり、すべての値は正確に1つのデータ型に属しています。Pythonで最も一般的なデータ型は[表1-2](#calibre_link-1653)にリストアップされています。例えば、`-2`と`30`という値は、*integer*値であると言われています。整数（または *int*）データ型は、整数である値を表します。 `3.14` のような小数点を持つ数値は *浮動小数点数* (または *floats*) と呼ばれます。`42` という値は整数ですが、`42.0` という値は浮動小数点数であることに注意してください。

**Table 1-2:** 一般的なデータ型

  **データ型**            **例**
  ------------------------ ----------------------------------------------------------------------------------------------------------------------------
  Integers                 `-2`, `-1`, `0`, `1`, `2`, `3`, `4`, `5`
  Floating-point numbers   `-1.25`, `-1.0`, `-0.5`, `0.0`, `0.5`, `1.0`, `1.25`
  Strings                  `'a'`, `'aa'`, `'aaa'`, `'Hello!'`, `'11 cats'`

Python プログラムは *string* または *strs* (「スターズ」と発音します) と呼ばれるテキスト値も持つことができます。文字列は常にシングルクォート (`'`) 文字で囲みます (`'Hello'` や `'Goodbye cruel world!'` のように) ので、Python は文字列がどこで始まり、どこで終わるかを知ることができます。文字列の中に何もない `''` という文字列もあり、これは *blank string* または *empty string* と呼ばれます。文字列については [第4章](#calibre_link-152) でより詳しく説明されています。

もしあなたが、`SyntaxError: EOL while scanning string literal` というエラーメッセージを見た場合、おそらく次の例のように、文字列の最後にシングルクォート文字を忘れているのでしょう。

```
>>> 'Hello, world!
SyntaxError: EOL while scanning string literal
```


### **文字列の連結と複製** 

演算子の意味は、演算子の隣にある値のデータ型によって変わることがあります。たとえば、`+` は、2つの整数または浮動小数点数に対して操作する場合は加算演算子です。しかし、`+` が2つの文字列の値に対して使われるときは、*文字列連結* 演算子として文字列を連結することになります。対話型シェルに次のように入力します．

```
>>> 'Alice' + 'Bob'
'AliceBob'
```

この式は、2つの文字列のテキストを結合した1つの新しい文字列の値として評価されます。しかし、文字列と整数値に対して `+` 演算子を使おうとすると、Python はこれをどのように扱えばよいのかわからず、エラーメッセージを表示します。

```
>>> 'Alice' + 42
Traceback (most recent call last):
  File "<pyshell#0>", line 1, in <module>
    'Alice' + 42
TypeError: can only concatenate str (not "int") to str
```

エラーメッセージ `can only concatenate str (not "int") to str` は、Python が `'Alice'` という文字列に整数を連結しようとしたと考えたことを意味します。Pythonはこれを自動的に行うことはできないので、あなたのコードは明示的に整数を文字列に変換しなければなりません。(データ型の変換については、"[Dissecting Your Program](#calibre_link-97)" [Page 13](#calibre_link-762) で `str()`, `int()`, `float()` 関数について説明しています)。

演算子 `*` は、2 つの整数値または浮動小数点値を掛け合わせます。しかし、`*` 演算子が1つの文字列値と1つの整数値に対して使われる場合、それは *文字列複製* 演算子となります。 対話型シェルに文字列と数値を掛け合わせたものを入力すると、この動作を見ることができます。

```
>>> 'Alice' * 5
'AliceAliceAliceAliceAlice'
```

この式は、元の文字列を整数値と同じ回数だけ繰り返した1つの文字列値として評価されます。文字列の複製は便利なトリックですが、文字列の連結ほど頻繁に使用されるものではありません。

演算子 `*` は、2つの数値（乗算の場合）、または1つの文字列値と1つの整数値（文字列の複製の場合）に対してのみ使用することができます。そうでない場合、Pythonは以下のようなエラーメッセージを表示するだけです。

```
>>> 'Alice' * 'Bob'
Traceback (most recent call last):
  File "<pyshell#32>", line 1, in <module>
    'Alice' * 'Bob'
TypeError: can't multiply sequence by non-int of type 'str'
>>> 'Alice' * 5.0
Traceback (most recent call last):
  File "<pyshell#33>", line 1, in <module>
    'Alice' * 5.0
TypeError: can't multiply sequence by non-int of type 'float'
```

Pythonがこのような式を理解できないのは当然です。2つの単語を掛け合わせることはできませんし、任意の文字列を何度も複製することは困難です。

### **変数に値を格納する** 

*変数*とは、コンピュータのメモリ内にある箱のようなもので、そこに一つの値を保存することができます。評価された式の結果をプログラムの後半で使用したい場合、変数内に保存することができます。

#### ***割り当て文*** 

変数に値を格納するには、*代入文*を使用します。代入文は、変数名、等号（*代入演算子*と呼ばれる）、格納する値から構成されます。もし、`spam = 42` という代入文を入力すると、`spam` という変数に `42` という整数の値が格納されます。

[図1-1](#calibre_link-1654)のように、変数は値を入れるラベルの付いた箱だと考えてください。


![image](../images/000026.jpg)


*図1-1: `spam = 42` は、プログラムに "変数 `spam` には今整数値 `42` が入っていますよ" と言っているようなものです。*

例えば、対話型シェルに次のように入力します。

```
[➊] >>> spam = 40
   >>> spam
   40
   >>> eggs = 2
[➋] >>> spam + eggs
   42
   >>> spam + eggs + spam
   82
[➌] >>> spam = spam + 2
   >>> spam
   42
```

変数は、`➊`にて最初に値が格納されたときに*初期化*されます。その後、他の変数や値と一緒に式の中で使うことができるようになります`➋`。変数に新しい値が代入されると`➌`、古い値は忘れられます。このため、例の最後では `spam` の評価値が `40` ではなく `42` になっていました。これを変数の *上書き* と呼びます。対話型シェルに次のコードを入力して、文字列の上書きを試してみてください。

```
>>> spam = 'Hello'
>>> spam
'Hello'
>>> spam = 'Goodbye'
>>> spam
'Goodbye'
```

[図 1-2](#calibre_link-1655) のボックスと同じように、この例では `spam` 変数に `'Hello'` という文字列を、 `'Goodbye'` に置き換えるまで格納しています。


![image](../images/000097.jpg)


*図1-2: 変数に新しい値が代入されると、古い値は忘れ去られる。*

#### ***変数名*** 

良い変数名は、それが含むデータを説明するものです。新しい家に引っ越したとき、引っ越し用の箱をすべて*Stuff*とラベル付けしたと想像してください。 何も見つからないでしょう! この本のほとんどの例（そしてPythonのドキュメント）では、 `spam`, `eggs`, `bacon` のような一般的な変数名を使用していますが、これはMonty Pythonの "Spam" スケッチから由来しています。しかし、あなたのプログラムでは、説明的な名前を付けることで、コードをより読みやすくすることができます。

変数の名前はほとんど何でもいいのですが、Pythonには命名上の制限があります。[表1-3](#calibre_link-1656)は、合法的な変数名の例を持っています。次の3つの規則に従う限り、変数にどんな名前を付けてもかまいません。

- スペースなしの1単語のみ使用可能です。
- 使用できる文字はアルファベット、数字、アンダースコア(`_`)のみです。
- 数字で始めることはできません。

**表1-3:** 有効な変数名と無効な変数名

  **有効な変数名**      **無効な変数名**
  ----------------------------- ----------------------------------------------------------------------------------
  `current_balance`   `current-balance` (ハイフンは使用できません)
  `currentBalance`    `current balance` (スペースは使用できません)
  `account4`          `4account` (数字始まりは不可)
   `_42`              `42` (数字始まりは不可)
  `TOTAL_SUM`         `TOTAL_$UM` (`$`のような特殊文字は使用できません。)
  `hello`             `'hello'` (`'` などの特殊文字は使用できません。)

変数名は大文字と小文字を区別します。つまり、 `spam`、`SPAM`、`Spam`、`sPaM` は4つの異なる変数ということになります。`spam` はプログラムの中で使える有効な変数ですが、変数を小文字で始めるのが Python の慣例です。

この本では、アンダースコアの代わりに*キャメルケース*を変数名に使っています。つまり、変数 `look_like_this` の代わりに `lookLikeThis` を使っています。経験豊富なプログラマの中には、Pythonの公式コードスタイルであるPEP 8ではアンダースコアを使うべきだと指摘している人もいるかもしれません。私は堂々とキャメルケースを好みますし、PEP 8 自体の "A Foolish Consistency Is the Hobgoblin of Little Minds" というセクションを指摘しています。

スタイルガイドとの整合性は重要です。しかし、最も重要なことは、一貫性がないことを自覚することです---時には、スタイルガイドが適用されないこともあります。疑問があるときは、最善の判断を下すことです。

### **初めてのプログラム** 

対話型シェルはPythonの命令を1つずつ実行するのに適していますが、Pythonのプログラム全体を書くには、ファイルエディタに命令を入力することになります。*ファイルエディタ*は、メモ帳やTextMateのようなテキストエディタに似ていますが、ソースコードを入力するための特別な機能を備えています。Muで新しいファイルを開くには、一番上の行にある**New**ボタンをクリックします。

表示されたウィンドウには、入力を待つカーソルが表示されているはずですが、`ENTER`を押すとすぐにPythonの命令が実行されるインタラクティブシェルとは異なります。ファイルエディタでは、多くの命令を入力し、ファイルを保存し、プログラムを実行することができます。ここでは、この2つの違いを見分ける方法を説明します。

- 対話型シェルウィンドウは常に `>>>` プロンプトが表示されます。
- ファイルエディタウィンドウには `>>>` プロンプトは表示されません。

さて、いよいよ最初のプログラムを作ってみましょう! ファイルエディタウィンドウが開いたら、次のように入力します。

```
[➊] # This program says hello and asks for my name.

[➋] print('Hello, world!')
   print('What is your name?')    # ask for their name
[➌] myName = input()
[➍] print('It is good to meet you, ' + myName)
[➎] print('The length of your name is:')
   print(len(myName))
[➏] print('What is your age?')    # ask for their age
   myAge = input()
   print('You will be ' + str(int(myAge) + 1) + ' in a year.')
```

ソースコードを入力したら、Muを起動するたびに入力し直さなくてもいいように保存しておきます。**Save**ボタンをクリックし、File Nameフィールドに*hello.py*を入力し、**Save**をクリックします。

プログラムは、たまに入力しながら保存しておくとよいでしょう。 そうすれば、コンピュータがクラッシュしたり、誤ってMuを終了してしまっても、コードを失うことはないでしょう。ショートカットとして、WindowsとLinuxでは `CTRL`-S を、macOSでは ![image](../images/000064.jpg)-S を押してファイルを保存することができます。

保存したら、プログラムを実行してみましょう。**F5**キーを押してください。対話型シェルウィンドウでプログラムが実行されるはずです。対話型シェルウィンドウではなく、ファイルエディタウィンドウから**F5**キーを押す必要があることを忘れないでください。プログラムが名前を聞いてきたら、あなたの名前を入力してください。対話型シェルでのプログラムの出力は、次のようになります。

```
Python 3.7.0b4 (v3.7.0b4:eb96c37699, May  2 2018, 19:02:22) [MSC v.1913
64 bit
(AMD64)] on win32
Type "copyright", "credits" or "license()" for more information.
>>> ================================ RESTART
================================
>>>
Hello, world!
What is your name?
[Al]
It is good to meet you, Al
The length of your name is:
2
What is your age?
[4]
You will be 5 in a year.
>>>
```

実行するコード行がなくなると、Pythonプログラムは*終了*、つまり実行を停止します。(Pythonプログラムが終了するとも言えます）。

ファイルエディタを閉じるには、ウィンドウの上部にあるXをクリックします。保存したプログラムを再読み込みするには、メニューから **File**▸**Open...** を選択します。表示されたウィンドウで ***hello.py*** を選択し、**Open** ボタンをクリックします。以前保存した *hello.py* プログラムがファイルエディター・ウィンドウに開くはずです。

Python Tutorの可視化ツールを使って、プログラムの実行を*[http://pythontutor.com/](http://pythontutor.com/)*で見ることができます。このプログラムの実行の様子は *[https://autbor.com/hellopy/](https://autbor.com/hellopy/)* で見ることができます。 プログラムの実行の各ステップを移動するには、forwardボタンをクリックします。変数の値や出力がどのように変化するかを見ることができます。

### **プログラムを分解する** 

ファイルエディタで新しいプログラムを開き、そのプログラムが使用しているPythonの命令について、それぞれの行が何を行っているかを簡単に見てみましょう。

#### ***コメント*** 

次の行は*コメント*と呼ばれます。

```
[➊] # This program says hello and asks for my name.
```

Python はコメントを無視するので、メモを書いたり、コードが何をしようとしているのか思い出すのに使うことができます。ハッシュマーク(`#`)に続く残りの行のテキストはすべてコメントの一部です。

時々、プログラマーはプログラムのテスト中に、一時的にコードを削除するために `#` を行の前に置くことがあります。これは *コメントアウト* と呼ばれ、プログラムがなぜ動作しないかを調べるときに便利です。後で行を戻す準備ができたら `#` を削除すればよいのです。

Python はコメントの後の空白行も無視します。プログラムには好きなだけ空白行を追加することができます。こうすることで、本の段落のように、コードを読みやすくすることができます。

#### ***print()関数*** 

`print()` 関数は、括弧の中にある文字列の値を画面に表示します。

```
[➋] print('Hello, world!')
   print('What is your name?') # ask for their name
```

`print('Hello, world!')` という行は、"文字列 `'Hello, world!'` のテキストをプリントアウトする" という意味です。Pythonがこの行を実行するとき、Pythonは `print()` 関数を *calling* しており、文字列の値が関数に *passed* されていると言うことになります。関数呼び出しに渡される値は *引数* です。引用符は画面に表示されないことに注意してください。引用符は文字列の始まりと終わりを示すだけで、文字列の値の一部ではありません。


**[NOTE]**

*この関数は、画面に空白行を表示するのにも使うことができます。*


関数名を書くときは、最後の開閉括弧で関数名であることを識別します。このため、この本では `print` ではなく `print()` と表記しています。[第3章](#calibre_link-132)では、関数についてより詳しく説明しています。

#### ***input()関数*** 

`input()` 関数は、ユーザーがキーボードにテキストを入力して `ENTER` を押すのを待ちます。

```
[➌] myName = input()
```

この関数呼び出しは、ユーザーのテキストと同じ文字列として評価され、このコードの行は `myName` 変数にこの文字列値を代入しています。

`input()` 関数の呼び出しは、ユーザーが入力した文字列に対して評価される式と考えることができます。もし、ユーザーが `'Al'` と入力した場合、この式は `myName = 'Al'` と評価されます。

もしあなたが `input()` を呼び出したときに `NameError: name 'Al' is not defined` のようなエラーメッセージが表示されたら、それは Python 3 ではなく Python 2 でコードを実行していることが問題なのです。

#### ***ユーザー名の印字*** 

次の `print()` の呼び出しは、実際には括弧の間に `'It is good to meet you, ' + myName` という式を含んでいます。

```
[➍] print('It is good to meet you, ' + myName)
```

式は常に1つの値に対して評価されることを覚えておいてください。もし `'Al'` がライン [➌] の `myName` に格納されている値であれば、この式は `'It is good to meet you, Al'` と評価されます。この単一の文字列の値は `print()` に渡され、スクリーンに表示されます。

#### ***len()関数*** 

関数 `len()` に文字列の値（または文字列を含む変数）を渡すと、その文字列の文字数を表す整数値として評価されます。

```
[➎] print('The length of your name is:')
   print(len(myName))
```

対話型シェルに以下を入力して試してみてください。

```
>>> len('hello')
5
>>> len('My very energetic monster just scarfed nachos.')
46
>>> len('')
0
```

これらの例と同じように、 `len(myName)` は整数として評価されます。そして、それを `print()` に渡して画面に表示させます。`print()` 関数には、整数値でも文字列でも渡すことができますが、対話型シェルに次のように入力すると、エラーが表示されることに注意してください。

```
 >>> print('I am ' + 29 + ' years old.')
Traceback (most recent call last):
  File "<pyshell#6>", line 1, in <module>
    print('I am ' + 29 + ' years old.')
TypeError: can only concatenate str (not "int") to str
```

`print()` 関数がこのエラーを引き起こしているのではなく、 `print()` に渡そうとした式が原因なのです。この式を単独で対話型シェルに入力しても、同じエラーメッセージが表示されます。

```
>>> 'I am ' + 29 + ' years old.'
Traceback (most recent call last):
  File "<pyshell#7>", line 1, in <module>
    'I am ' + 29 + ' years old.'
TypeError: can only concatenate str (not "int") to str
```

Pythonはエラーを出します。なぜなら `+` 演算子は2つの整数を足すか、2つの文字列を連結するためにしか使えないからです。Pythonでは非文法的なので、整数を文字列に加えることはできません。次のセクションで説明するように、整数の文字列バージョンを使用することでこれを解決することができます。

#### ***str()、int()、float() 関数*** 

もし `29` のような整数を文字列に連結して `print()` に渡したい場合は、 `29` の文字列形式である `'29'` という値を取得する必要があります。`str()` 関数には整数の値を渡すことができ、以下のように整数の文字列バージョンとして評価されます。

```
>>> str(29)
'29'
>>> print('I am ' + str(29) + ' years old.')
I am 29 years old.
```

`str(29)` は `'29'` と評価されるので、 `'I am ' + str(29) + ' years old.'` という式は `'I am ' + '29' + ' years old.'` と評価され、その結果 `'I am 29 years old.'` と評価されることになる。これは `print()` 関数に渡される値です。

`str()`、`int()`、`float()` の各関数は、渡した値をそれぞれ文字列、整数、浮動小数点の形で評価します。対話型シェルでこれらの関数を使っていくつかの値を変換し、何が起こるか見てみましょう。

```
>>> str(0)
'0'
>>> str(-3.14)
'-3.14'
>>> int('42')
42
>>> int('-99')
-99
>>> int(1.25)
1
>>> int(1.99)
1
>>> float('3.14')
3.14
>>> float(10)
10.0
```

これまでの例では、 `str()`, `int()`, `float()` 関数を呼び出して、他のデータ型の値を渡して、それらの値の文字列、整数、浮動小数点数の形式を取得することができました。

`str()`関数は、整数や浮動小数点数を文字列に連結したいときに便利です。また、 `int()` 関数は、数値を文字列の値として持っていて、それを数学で使いたい場合にも役に立ちます。例えば、`input()`関数は、ユーザが数値を入力しても常に文字列を返します。 対話型シェルに `spam = input()` と入力し、文字列を待つ間に `101` と入力してみてください。

```
>>> spam = input()
101
>>> spam
'101'
```

`spam` の中に格納されている値は、整数の `101` ではなく、文字列の `'101'` です。もし、 `spam` の値を使って計算を行いたい場合は、 `int()` 関数を使って `spam` の整数型を取得し、これを `spam` に新しい値として格納します。

```
>>> spam = int(spam)
>>> spam
101
```

これで、変数 `spam` を文字列ではなく、整数として扱えるようになりました。

```
>>> spam * 10 / 5
202.0
```

`int()` に整数として評価できない値を渡すと、Python はエラーメッセージを表示することに注意してください。

```
>>> int('99.99')
Traceback (most recent call last):
  File "<pyshell#18>", line 1, in <module>
    int('99.99')
ValueError: invalid literal for int() with base 10: '99.99'
>>> int('twelve')
Traceback (most recent call last):
  File "<pyshell#19>", line 1, in <module>
    int('twelve')
ValueError: invalid literal for int() with base 10: 'twelve'
```

`int()`関数は、浮動小数点数を切り捨てる必要がある場合にも便利です。

```
>>> int(7.7)
7
>>> int(7.7) + 1
8
```

あなたは、プログラムの最後の3行で`int()`と`str()`の関数を使い、コードに適したデータ型の値を取得しましたね。

```
[➏] print('What is your age?') \# ask for their age
   myAge = input()
   print('You will be ' + str(int(myAge) + 1) + ' in a year.')
```


**文章と数字の一致**

数値の文字列値は、整数値や浮動小数点数とは全く別の値として扱われますが、整数は浮動小数点数と等しくなることがあります。

```
>>> 42 == '42'
False
>>> 42 == 42.0
True
>>> 42.0 == 0042.000
True
```

Pythonでは、文字列はテキスト、整数と浮動小数点はともに数値であるため、このような区別をしています。


変数 `myAge` には `input()` から返された値が格納されます。`input()` 関数は常に文字列を返すので（ユーザーが数字を入力した場合でも）、 `int(myAge)` コードを使って `myAge` の文字列を整数値で返すことができます。この整数値は次に `int(myAge) + 1` という式で `1` を足したものになります。

この足し算の結果が `str()` 関数に渡される: `str(int(myAge) + 1)`. 返された文字列は `'You will be '` と `' in a year.'` という文字列と連結され、一つの大きな文字列として評価されます。この大きな文字列は、最後に `print()` に渡され、画面に表示される。

例えば、ユーザが `myAge` に `'4'` という文字列を入力したとしましょう。文字列 `'4'` は整数に変換されるので、それに 1 を足すことができる。その結果は `5` です。`str()` 関数は結果を文字列に戻すので、2番目の文字列 `'in a year.'` と連結して、最後のメッセージを作成することができます。これらの評価ステップは次のようになります。


![image](../images/000017.jpg)


### **まとめ** 

電卓で式を計算したり、ワープロで文字列の連結を入力したりすることができます。文字列の複製もコピーアンドペーストで簡単にできる。しかし、式とその構成要素である演算子、変数、関数呼び出しは、プログラムを作るための基本的な構成要素である。これらを使いこなせば、Pythonに大量のデータを処理させることができるようになります。

この章で紹介した演算子の種類(数学演算では `+`, `-`, `*`, `/`, `//`, `%`, `**`, 文字列演算では `+`, `*`) と3つのデータ型（整数、浮動小数点数、文字列）は覚えておくとよいでしょう。

いくつかの異なる関数も紹介しました。`print()` と `input()` 関数は、単純なテキストの出力（画面への）と入力（キーボードからの）を扱います。`len()` 関数は文字列を受け取って、その文字列の文字数を int 値で評価します。`str()`、`int()`、`float()`関数は、渡された値の文字列、整数、浮動小数点数のいずれかの形式で評価します。

次の章では、どのコードを実行し、どのコードをスキップし、どのコードを繰り返すかを、その値に基づいてインテリジェントに決定するようPythonに指示する方法を学びます。これは*フロー制御*として知られており、インテリジェントな決定を行うプログラムを書くことができます。

### **練習問題** 

[1](#calibre_link-1657). 次のうちどれが演算子で、どれが値か？

```
*
'hello'
-88.8
-
/
+
5
```

[2](#calibre_link-1658). 次のうち、変数はどれで、文字列はどれですか？

```
spam
'spam'
```

[3](#calibre_link-1659). 3つのデータ型を挙げなさい。

[4](#calibre_link-1660). 式は何からできているのか？すべての式は何をするのか？

[5](#calibre_link-1661). この章では、`spam = 10`のような代入文について紹介しました。式と文の違いは何でしょうか？

[6](#calibre_link-1662). 次のコードが実行された後、変数 `bacon` には何が入っているか？

```
bacon = 20
bacon + 1
```

[7](#calibre_link-1663). 次の2つの式は、どのように評価されるべきでしょうか？

```
'spam' + 'spamspam'
'spam' * 3
```

[8](#calibre_link-1664). なぜ `eggs` は有効な変数名で、`100` は無効なのですか？

[9](#calibre_link-1665). 値の整数版、浮動小数点数版、文字列版を取得するために使用できる3つの関数は何ですか？

[10](#calibre_link-1666).  この式はなぜエラーになるのですか？どうしたら直せますか？

```
'I have eaten ' + 99 + ' burritos.'
```

**Extra credit:** オンラインで `len()` 関数の Python ドキュメントを検索してください。それは "Built-in Functions" と題されたウェブページにあります。Python が持つ他の関数のリストに目を通し、 `round()` 関数が何をするのか調べて、対話型シェルで実験してみましょう。

